/*! guxiaoming:8138f7606ba95e6dc5f3d345dc9a6a199ae7015a */
!function(I,g){if("object"==typeof exports&&"object"==typeof module)module.exports=g();else if("function"==typeof define&&define.amd)define([],g);else{var C=g();for(var A in C)("object"==typeof exports?exports:I)[A]=C[A]}}(window,(function(){return function(I){var g={};function C(A){if(g[A])return g[A].exports;var c=g[A]={i:A,l:!1,exports:{}};return I[A].call(c.exports,c,c.exports,C),c.l=!0,c.exports}return C.m=I,C.c=g,C.d=function(I,g,A){C.o(I,g)||Object.defineProperty(I,g,{enumerable:!0,get:A})},C.r=function(I){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(I,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(I,"__esModule",{value:!0})},C.t=function(I,g){if(1&g&&(I=C(I)),8&g)return I;if(4&g&&"object"==typeof I&&I&&I.__esModule)return I;var A=Object.create(null);if(C.r(A),Object.defineProperty(A,"default",{enumerable:!0,value:I}),2&g&&"string"!=typeof I)for(var c in I)C.d(A,c,function(g){return I[g]}.bind(null,c));return A},C.n=function(I){var g=I&&I.__esModule?function(){return I.default}:function(){return I};return C.d(g,"a",g),g},C.o=function(I,g){return Object.prototype.hasOwnProperty.call(I,g)},C.p="",C(C.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/srs.sdk.js\n\n//\n// Copyright (c) 2013-2021 Winlin\n//\n// SPDX-License-Identifier: MIT\n//\n\n\n\nfunction SrsError(name, message) {\n    this.name = name;\n    this.message = message;\n    this.stack = (new Error()).stack;\n}\nSrsError.prototype = Object.create(Error.prototype);\nSrsError.prototype.constructor = SrsError;\n\n// Depends on adapter-7.4.0.min.js from https://github.com/webrtc/adapter\n// Async-awat-prmise based SRS RTC Publisher.\nfunction SrsRtcPublisherAsync() {\n    var self = {};\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia\n    self.constraints = {\n        audio: true,\n        video: {\n            width: {ideal: 320, max: 576}\n        }\n    };\n\n    // @see https://github.com/rtcdn/rtcdn-draft\n    // @url The WebRTC url to play with, for example:\n    //      webrtc://r.ossrs.net/live/livestream\n    // or specifies the API port:\n    //      webrtc://r.ossrs.net:11985/live/livestream\n    // or autostart the publish:\n    //      webrtc://r.ossrs.net/live/livestream?autostart=true\n    // or change the app from live to myapp:\n    //      webrtc://r.ossrs.net:11985/myapp/livestream\n    // or change the stream from livestream to mystream:\n    //      webrtc://r.ossrs.net:11985/live/mystream\n    // or set the api server to myapi.domain.com:\n    //      webrtc://myapi.domain.com/live/livestream\n    // or set the candidate(eip) of answer:\n    //      webrtc://r.ossrs.net/live/livestream?candidate=39.107.238.185\n    // or force to access https API:\n    //      webrtc://r.ossrs.net/live/livestream?schema=https\n    // or use plaintext, without SRTP:\n    //      webrtc://r.ossrs.net/live/livestream?encrypt=false\n    // or any other information, will pass-by in the query:\n    //      webrtc://r.ossrs.net/live/livestream?vhost=xxx\n    //      webrtc://r.ossrs.net/live/livestream?token=xxx\n    self.publish = async function (url) {\n        var conf = self.__internal.prepareUrl(url);\n        self.pc.addTransceiver("audio", {direction: "sendonly"});\n        self.pc.addTransceiver("video", {direction: "sendonly"});\n\n        if (!navigator.mediaDevices && window.location.protocol === \'http:\' && window.location.hostname !== \'localhost\') {\n            throw new SrsError(\'HttpsRequiredError\', `Please use HTTPS or localhost to publish, read https://github.com/ossrs/srs/issues/2762#issuecomment-983147576`);\n        }\n        var stream = await navigator.mediaDevices.getUserMedia(self.constraints);\n\n        // @see https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addStream#Migrating_to_addTrack\n        stream.getTracks().forEach(function (track) {\n            self.pc.addTrack(track);\n\n            // Notify about local track when stream is ok.\n            self.ontrack && self.ontrack({track: track});\n        });\n\n        var offer = await self.pc.createOffer();\n        await self.pc.setLocalDescription(offer);\n        var session = await new Promise(function (resolve, reject) {\n            // @see https://github.com/rtcdn/rtcdn-draft\n            var data = {\n                api: conf.apiUrl, tid: conf.tid, streamurl: conf.streamUrl,\n                clientip: null, sdp: offer.sdp\n            };\n            console.log("Generated offer: ", data);\n\n            const xhr = new XMLHttpRequest();\n            xhr.onload = function() {\n                if (xhr.readyState !== xhr.DONE) return;\n                if (xhr.status !== 200) return reject(xhr);\n                const data = JSON.parse(xhr.responseText);\n                console.log("Got answer: ", data);\n                return data.code ? reject(xhr) : resolve(data);\n            }\n            xhr.open(\'POST\', conf.apiUrl, true);\n            xhr.setRequestHeader(\'Content-type\', \'application/json\');\n            xhr.send(JSON.stringify(data));\n        });\n        await self.pc.setRemoteDescription(\n            new RTCSessionDescription({type: \'answer\', sdp: session.sdp})\n        );\n        session.simulator = conf.schema + \'//\' + conf.urlObject.server + \':\' + conf.port + \'/rtc/v1/nack/\';\n\n        return session;\n    };\n\n    // Close the publisher.\n    self.close = function () {\n        self.pc && self.pc.close();\n        self.pc = null;\n    };\n\n    // The callback when got local stream.\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addStream#Migrating_to_addTrack\n    self.ontrack = function (event) {\n        // Add track to stream of SDK.\n        self.stream.addTrack(event.track);\n    };\n\n    // Internal APIs.\n    self.__internal = {\n        defaultPath: \'/rtc/v1/publish/\',\n        prepareUrl: function (webrtcUrl) {\n            var urlObject = self.__internal.parse(webrtcUrl);\n\n            // If user specifies the schema, use it as API schema.\n            var schema = urlObject.user_query.schema;\n            schema = schema ? schema + \':\' : window.location.protocol;\n\n            var port = urlObject.port || 1985;\n            if (schema === \'https:\') {\n                port = urlObject.port || 443;\n            }\n\n            // @see https://github.com/rtcdn/rtcdn-draft\n            var api = urlObject.user_query.play || self.__internal.defaultPath;\n            if (api.lastIndexOf(\'/\') !== api.length - 1) {\n                api += \'/\';\n            }\n\n            apiUrl = schema + \'//\' + urlObject.server + \':\' + port + api;\n            for (var key in urlObject.user_query) {\n                if (key !== \'api\' && key !== \'play\') {\n                    apiUrl += \'&\' + key + \'=\' + urlObject.user_query[key];\n                }\n            }\n            // Replace /rtc/v1/play/&k=v to /rtc/v1/play/?k=v\n            var apiUrl = apiUrl.replace(api + \'&\', api + \'?\');\n\n            var streamUrl = urlObject.url;\n\n            return {\n                apiUrl: apiUrl, streamUrl: streamUrl, schema: schema, urlObject: urlObject, port: port,\n                tid: Number(parseInt(new Date().getTime()*Math.random()*100)).toString(16).slice(0, 7)\n            };\n        },\n        parse: function (url) {\n            // @see: http://stackoverflow.com/questions/10469575/how-to-use-location-object-to-parse-url-without-redirecting-the-page-in-javascri\n            var a = document.createElement("a");\n            a.href = url.replace("rtmp://", "http://")\n                .replace("webrtc://", "http://")\n                .replace("rtc://", "http://");\n\n            var vhost = a.hostname;\n            var app = a.pathname.substring(1, a.pathname.lastIndexOf("/"));\n            var stream = a.pathname.slice(a.pathname.lastIndexOf("/") + 1);\n\n            // parse the vhost in the params of app, that srs supports.\n            app = app.replace("...vhost...", "?vhost=");\n            if (app.indexOf("?") >= 0) {\n                var params = app.slice(app.indexOf("?"));\n                app = app.slice(0, app.indexOf("?"));\n\n                if (params.indexOf("vhost=") > 0) {\n                    vhost = params.slice(params.indexOf("vhost=") + "vhost=".length);\n                    if (vhost.indexOf("&") > 0) {\n                        vhost = vhost.slice(0, vhost.indexOf("&"));\n                    }\n                }\n            }\n\n            // when vhost equals to server, and server is ip,\n            // the vhost is __defaultVhost__\n            if (a.hostname === vhost) {\n                var re = /^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/;\n                if (re.test(a.hostname)) {\n                    vhost = "__defaultVhost__";\n                }\n            }\n\n            // parse the schema\n            var schema = "rtmp";\n            if (url.indexOf("://") > 0) {\n                schema = url.slice(0, url.indexOf("://"));\n            }\n\n            var port = a.port;\n            if (!port) {\n                // Finger out by webrtc url, if contains http or https port, to overwrite default 1985.\n                if (schema === \'webrtc\' && url.indexOf(`webrtc://${a.host}:`) === 0) {\n                    port = (url.indexOf(`webrtc://${a.host}:80`) === 0) ? 80 : 443;\n                }\n\n                // Guess by schema.\n                if (schema === \'http\') {\n                    port = 80;\n                } else if (schema === \'https\') {\n                    port = 443;\n                } else if (schema === \'rtmp\') {\n                    port = 1935;\n                }\n            }\n\n            var ret = {\n                url: url,\n                schema: schema,\n                server: a.hostname, port: port,\n                vhost: vhost, app: app, stream: stream\n            };\n            self.__internal.fill_query(a.search, ret);\n\n            // For webrtc API, we use 443 if page is https, or schema specified it.\n            if (!ret.port) {\n                if (schema === \'webrtc\' || schema === \'rtc\') {\n                    if (ret.user_query.schema === \'https\') {\n                        ret.port = 443;\n                    } else if (window.location.href.indexOf(\'https://\') === 0) {\n                        ret.port = 443;\n                    } else {\n                        // For WebRTC, SRS use 1985 as default API port.\n                        ret.port = 1985;\n                    }\n                }\n            }\n\n            return ret;\n        },\n        fill_query: function (query_string, obj) {\n            // pure user query object.\n            obj.user_query = {};\n\n            if (query_string.length === 0) {\n                return;\n            }\n\n            // split again for angularjs.\n            if (query_string.indexOf("?") >= 0) {\n                query_string = query_string.split("?")[1];\n            }\n\n            var queries = query_string.split("&");\n            for (var i = 0; i < queries.length; i++) {\n                var elem = queries[i];\n\n                var query = elem.split("=");\n                obj[query[0]] = query[1];\n                obj.user_query[query[0]] = query[1];\n            }\n\n            // alias domain for vhost.\n            if (obj.domain) {\n                obj.vhost = obj.domain;\n            }\n        }\n    };\n\n    self.pc = new RTCPeerConnection(null);\n\n    // To keep api consistent between player and publisher.\n    // @see https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addStream#Migrating_to_addTrack\n    // @see https://webrtc.org/getting-started/media-devices\n    self.stream = new MediaStream();\n\n    return self;\n}\n\n// Depends on adapter-7.4.0.min.js from https://github.com/webrtc/adapter\n// Async-await-promise based SRS RTC Player.\nfunction SrsRtcPlayerAsync() {\n    var self = {};\n\n    // @see https://github.com/rtcdn/rtcdn-draft\n    // @url The WebRTC url to play with, for example:\n    //      webrtc://r.ossrs.net/live/livestream\n    // or specifies the API port:\n    //      webrtc://r.ossrs.net:11985/live/livestream\n    //      webrtc://r.ossrs.net:80/live/livestream\n    // or autostart the play:\n    //      webrtc://r.ossrs.net/live/livestream?autostart=true\n    // or change the app from live to myapp:\n    //      webrtc://r.ossrs.net:11985/myapp/livestream\n    // or change the stream from livestream to mystream:\n    //      webrtc://r.ossrs.net:11985/live/mystream\n    // or set the api server to myapi.domain.com:\n    //      webrtc://myapi.domain.com/live/livestream\n    // or set the candidate(eip) of answer:\n    //      webrtc://r.ossrs.net/live/livestream?candidate=39.107.238.185\n    // or force to access https API:\n    //      webrtc://r.ossrs.net/live/livestream?schema=https\n    // or use plaintext, without SRTP:\n    //      webrtc://r.ossrs.net/live/livestream?encrypt=false\n    // or any other information, will pass-by in the query:\n    //      webrtc://r.ossrs.net/live/livestream?vhost=xxx\n    //      webrtc://r.ossrs.net/live/livestream?token=xxx\n    self.play = async function(url) {\n        var conf = self.__internal.prepareUrl(url);\n        self.pc.addTransceiver("audio", {direction: "recvonly"});\n        self.pc.addTransceiver("video", {direction: "recvonly"});\n\n        var offer = await self.pc.createOffer();\n        await self.pc.setLocalDescription(offer);\n        var session = await new Promise(function(resolve, reject) {\n            // @see https://github.com/rtcdn/rtcdn-draft\n            var data = {\n                api: conf.apiUrl, tid: conf.tid, streamurl: conf.streamUrl,\n                clientip: null, sdp: offer.sdp\n            };\n            console.log("Generated offer: ", data);\n\n            const xhr = new XMLHttpRequest();\n            xhr.onload = function() {\n                if (xhr.readyState !== xhr.DONE) return;\n                if (xhr.status !== 200) return reject(xhr);\n                const data = JSON.parse(xhr.responseText);\n                console.log("Got answer: ", data);\n                return data.code ? reject(xhr) : resolve(data);\n            }\n            xhr.open(\'POST\', conf.apiUrl, true);\n            xhr.setRequestHeader(\'Content-type\', \'application/json\');\n            xhr.send(JSON.stringify(data));\n        });\n        await self.pc.setRemoteDescription(\n            new RTCSessionDescription({type: \'answer\', sdp: session.sdp})\n        );\n        session.simulator = conf.schema + \'//\' + conf.urlObject.server + \':\' + conf.port + \'/rtc/v1/nack/\';\n\n        return session;\n    };\n\n    // Close the player.\n    self.close = function() {\n        self.pc && self.pc.close();\n        self.pc = null;\n    };\n\n    // The callback when got remote track.\n    // Note that the onaddstream is deprecated, @see https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/onaddstream\n    self.ontrack = function (event) {\n        // https://webrtc.org/getting-started/remote-streams\n        self.stream.addTrack(event.track);\n    };\n\n    // Internal APIs.\n    self.__internal = {\n        defaultPath: \'/rtc/v1/play/\',\n        prepareUrl: function (webrtcUrl) {\n            var urlObject = self.__internal.parse(webrtcUrl);\n\n            // If user specifies the schema, use it as API schema.\n            var schema = urlObject.user_query.schema;\n            schema = schema ? schema + \':\' : window.location.protocol;\n\n            if(schema == "file:"){\n                schema = "http:";\n                console.log(schema);\n            }\n\n            var port = urlObject.port || 1985;\n            if (schema === \'https:\') {\n                port = urlObject.port || 443;\n            }\n\n            // @see https://github.com/rtcdn/rtcdn-draft\n            var api = urlObject.user_query.play || self.__internal.defaultPath;\n            if (api.lastIndexOf(\'/\') !== api.length - 1) {\n                api += \'/\';\n            }\n\n            apiUrl = schema + \'//\' + urlObject.server + \':\' + port + api;\n            for (var key in urlObject.user_query) {\n                if (key !== \'api\' && key !== \'play\') {\n                    apiUrl += \'&\' + key + \'=\' + urlObject.user_query[key];\n                }\n            }\n            // Replace /rtc/v1/play/&k=v to /rtc/v1/play/?k=v\n            var apiUrl = apiUrl.replace(api + \'&\', api + \'?\');\n\n            var streamUrl = urlObject.url;\n\n            return {\n                apiUrl: apiUrl, streamUrl: streamUrl, schema: schema, urlObject: urlObject, port: port,\n                tid: Number(parseInt(new Date().getTime()*Math.random()*100)).toString(16).slice(0, 7)\n            };\n        },\n        parse: function (url) {\n            // @see: http://stackoverflow.com/questions/10469575/how-to-use-location-object-to-parse-url-without-redirecting-the-page-in-javascri\n            var a = document.createElement("a");\n            a.href = url.replace("rtmp://", "http://")\n                .replace("webrtc://", "http://")\n                .replace("rtc://", "http://");\n\n            var vhost = a.hostname;\n            var app = a.pathname.substring(1, a.pathname.lastIndexOf("/"));\n            var stream = a.pathname.slice(a.pathname.lastIndexOf("/") + 1);\n\n            // parse the vhost in the params of app, that srs supports.\n            app = app.replace("...vhost...", "?vhost=");\n            if (app.indexOf("?") >= 0) {\n                var params = app.slice(app.indexOf("?"));\n                app = app.slice(0, app.indexOf("?"));\n\n                if (params.indexOf("vhost=") > 0) {\n                    vhost = params.slice(params.indexOf("vhost=") + "vhost=".length);\n                    if (vhost.indexOf("&") > 0) {\n                        vhost = vhost.slice(0, vhost.indexOf("&"));\n                    }\n                }\n            }\n\n            // when vhost equals to server, and server is ip,\n            // the vhost is __defaultVhost__\n            if (a.hostname === vhost) {\n                var re = /^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/;\n                if (re.test(a.hostname)) {\n                    vhost = "__defaultVhost__";\n                }\n            }\n\n            // parse the schema\n            var schema = "rtmp";\n            if (url.indexOf("://") > 0) {\n                schema = url.slice(0, url.indexOf("://"));\n            }\n\n            var port = a.port;\n            if (!port) {\n                // Finger out by webrtc url, if contains http or https port, to overwrite default 1985.\n                if (schema === \'webrtc\' && url.indexOf(`webrtc://${a.host}:`) === 0) {\n                    port = (url.indexOf(`webrtc://${a.host}:80`) === 0) ? 80 : 443;\n                }\n\n                // Guess by schema.\n                if (schema === \'http\') {\n                    port = 80;\n                } else if (schema === \'https\') {\n                    port = 443;\n                } else if (schema === \'rtmp\') {\n                    port = 1935;\n                }\n            }\n\n            var ret = {\n                url: url,\n                schema: schema,\n                server: a.hostname, port: port,\n                vhost: vhost, app: app, stream: stream\n            };\n            self.__internal.fill_query(a.search, ret);\n\n            // For webrtc API, we use 443 if page is https, or schema specified it.\n            if (!ret.port) {\n                if (schema === \'webrtc\' || schema === \'rtc\') {\n                    if (ret.user_query.schema === \'https\') {\n                        ret.port = 443;\n                    } else if (window.location.href.indexOf(\'https://\') === 0) {\n                        ret.port = 443;\n                    } else {\n                        // For WebRTC, SRS use 1985 as default API port.\n                        ret.port = 1985;\n                    }\n                }\n            }\n\n            return ret;\n        },\n        fill_query: function (query_string, obj) {\n            // pure user query object.\n            obj.user_query = {};\n\n            if (query_string.length === 0) {\n                return;\n            }\n\n            // split again for angularjs.\n            if (query_string.indexOf("?") >= 0) {\n                query_string = query_string.split("?")[1];\n            }\n\n            var queries = query_string.split("&");\n            for (var i = 0; i < queries.length; i++) {\n                var elem = queries[i];\n\n                var query = elem.split("=");\n                obj[query[0]] = query[1];\n                obj.user_query[query[0]] = query[1];\n            }\n\n            // alias domain for vhost.\n            if (obj.domain) {\n                obj.vhost = obj.domain;\n            }\n        }\n    };\n\n    //=========================\n    // const pcOptional ={\n    //     optional:[{googCpuOveruseDetection:false}]\n    //   };\n    // const configuration = {\n    //     iceServers: [{\n    //         urls: "turn:avc.agree.cn:50111",\n    //         username: "agree",\n    //         credential: "agree"\n    //     }], \n    //     iceTransportPolicy: "relay"\n    // }\n    // self.pc = new RTCPeerConnection(configuration,pcOptional);\n    //=========================\n    self.pc = new RTCPeerConnection(null);\n\n    // Create a stream to add track to the stream, @see https://webrtc.org/getting-started/remote-streams\n    self.stream = new MediaStream();\n\n    // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/ontrack\n    self.pc.ontrack = function(event) {\n        if (self.ontrack) {\n            self.ontrack(event);\n        }\n    };\n\n    return self;\n}\n\n// Format the codec of RTCRtpSender, kind(audio/video) is optional filter.\n// https://developer.mozilla.org/en-US/docs/Web/Media/Formats/WebRTC_codecs#getting_the_supported_codecs\nfunction SrsRtcFormatSenders(senders, kind) {\n    var codecs = [];\n    senders.forEach(function (sender) {\n        var params = sender.getParameters();\n        params && params.codecs && params.codecs.forEach(function(c) {\n            if (kind && sender.track.kind !== kind) {\n                return;\n            }\n\n            if (c.mimeType.indexOf(\'/red\') > 0 || c.mimeType.indexOf(\'/rtx\') > 0 || c.mimeType.indexOf(\'/fec\') > 0) {\n                return;\n            }\n\n            var s = \'\';\n\n            s += c.mimeType.replace(\'audio/\', \'\').replace(\'video/\', \'\');\n            s += \', \' + c.clockRate + \'HZ\';\n            if (sender.track.kind === "audio") {\n                s += \', channels: \' + c.channels;\n            }\n            s += \', pt: \' + c.payloadType;\n\n            codecs.push(s);\n        });\n    });\n    return codecs.join(", ");\n}\n\n\n// CONCATENATED MODULE: ./src/index.js\n\r\n\r\nclass src_client {\r\n    constructor() {\r\n        this.players =[];\r\n        this.playVideos =[];\r\n    }\r\n    initPlayer(streamAlias){\r\n        this.players[streamAlias] = new SrsRtcPlayerAsync();\r\n    }\r\n    play(url,video,streamAlias){\r\n        this.playVideos[streamAlias] = video;\r\n        let player =this.players[streamAlias];\r\n        video.srcObject = player.stream;\r\n        player.play(url).then(function (session) {\r\n            console.log(url);\r\n        }).catch(function (reason) {\r\n            player.close();\r\n            console.error(reason);\r\n        });\r\n    }\r\n    stopPlay(streamAlias){\r\n        this.playVideos[streamAlias].srcObject = null;\r\n        this.players[streamAlias].close();\r\n    }\r\n}\r\nsrc_client = new src_client();\r\n/* harmony default export */ var src = (src_client);\r\n\n// CONCATENATED MODULE: ./src/amps.js\n\r\nwindow.ampsSDK = {\r\n    initPlayer: function (streamAlias) {\r\n        console.log("AMPS-initPlayer");\r\n        src.initPlayer(streamAlias);\r\n    },\r\n    play: function (url,video,streamAlias) { \r\n        console.log("AMPS-play");\r\n        src.play(url,video,streamAlias);\r\n    },\r\n    stopPlay: function (streamAlias) {\r\n        console.log("AMPS-stopPlay");\r\n        src.stopPlay(streamAlias);\r\n    }\r\n\r\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zcnMuc2RrLmpzPzllYTYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzP2I2MzUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FtcHMuanM/NjNmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8vXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTMtMjAyMSBXaW5saW5cbi8vXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUXG4vL1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIFNyc0Vycm9yKG5hbWUsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG59XG5TcnNFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5TcnNFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcnNFcnJvcjtcblxuLy8gRGVwZW5kcyBvbiBhZGFwdGVyLTcuNC4wLm1pbi5qcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGMvYWRhcHRlclxuLy8gQXN5bmMtYXdhdC1wcm1pc2UgYmFzZWQgU1JTIFJUQyBQdWJsaXNoZXIuXG5mdW5jdGlvbiBTcnNSdGNQdWJsaXNoZXJBc3luYygpIHtcbiAgICB2YXIgc2VsZiA9IHt9O1xuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhRGV2aWNlcy9nZXRVc2VyTWVkaWFcbiAgICBzZWxmLmNvbnN0cmFpbnRzID0ge1xuICAgICAgICBhdWRpbzogdHJ1ZSxcbiAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICAgIHdpZHRoOiB7aWRlYWw6IDMyMCwgbWF4OiA1NzZ9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcnRjZG4vcnRjZG4tZHJhZnRcbiAgICAvLyBAdXJsIFRoZSBXZWJSVEMgdXJsIHRvIHBsYXkgd2l0aCwgZm9yIGV4YW1wbGU6XG4gICAgLy8gICAgICB3ZWJydGM6Ly9yLm9zc3JzLm5ldC9saXZlL2xpdmVzdHJlYW1cbiAgICAvLyBvciBzcGVjaWZpZXMgdGhlIEFQSSBwb3J0OlxuICAgIC8vICAgICAgd2VicnRjOi8vci5vc3Nycy5uZXQ6MTE5ODUvbGl2ZS9saXZlc3RyZWFtXG4gICAgLy8gb3IgYXV0b3N0YXJ0IHRoZSBwdWJsaXNoOlxuICAgIC8vICAgICAgd2VicnRjOi8vci5vc3Nycy5uZXQvbGl2ZS9saXZlc3RyZWFtP2F1dG9zdGFydD10cnVlXG4gICAgLy8gb3IgY2hhbmdlIHRoZSBhcHAgZnJvbSBsaXZlIHRvIG15YXBwOlxuICAgIC8vICAgICAgd2VicnRjOi8vci5vc3Nycy5uZXQ6MTE5ODUvbXlhcHAvbGl2ZXN0cmVhbVxuICAgIC8vIG9yIGNoYW5nZSB0aGUgc3RyZWFtIGZyb20gbGl2ZXN0cmVhbSB0byBteXN0cmVhbTpcbiAgICAvLyAgICAgIHdlYnJ0YzovL3Iub3NzcnMubmV0OjExOTg1L2xpdmUvbXlzdHJlYW1cbiAgICAvLyBvciBzZXQgdGhlIGFwaSBzZXJ2ZXIgdG8gbXlhcGkuZG9tYWluLmNvbTpcbiAgICAvLyAgICAgIHdlYnJ0YzovL215YXBpLmRvbWFpbi5jb20vbGl2ZS9saXZlc3RyZWFtXG4gICAgLy8gb3Igc2V0IHRoZSBjYW5kaWRhdGUoZWlwKSBvZiBhbnN3ZXI6XG4gICAgLy8gICAgICB3ZWJydGM6Ly9yLm9zc3JzLm5ldC9saXZlL2xpdmVzdHJlYW0/Y2FuZGlkYXRlPTM5LjEwNy4yMzguMTg1XG4gICAgLy8gb3IgZm9yY2UgdG8gYWNjZXNzIGh0dHBzIEFQSTpcbiAgICAvLyAgICAgIHdlYnJ0YzovL3Iub3NzcnMubmV0L2xpdmUvbGl2ZXN0cmVhbT9zY2hlbWE9aHR0cHNcbiAgICAvLyBvciB1c2UgcGxhaW50ZXh0LCB3aXRob3V0IFNSVFA6XG4gICAgLy8gICAgICB3ZWJydGM6Ly9yLm9zc3JzLm5ldC9saXZlL2xpdmVzdHJlYW0/ZW5jcnlwdD1mYWxzZVxuICAgIC8vIG9yIGFueSBvdGhlciBpbmZvcm1hdGlvbiwgd2lsbCBwYXNzLWJ5IGluIHRoZSBxdWVyeTpcbiAgICAvLyAgICAgIHdlYnJ0YzovL3Iub3NzcnMubmV0L2xpdmUvbGl2ZXN0cmVhbT92aG9zdD14eHhcbiAgICAvLyAgICAgIHdlYnJ0YzovL3Iub3NzcnMubmV0L2xpdmUvbGl2ZXN0cmVhbT90b2tlbj14eHhcbiAgICBzZWxmLnB1Ymxpc2ggPSBhc3luYyBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHZhciBjb25mID0gc2VsZi5fX2ludGVybmFsLnByZXBhcmVVcmwodXJsKTtcbiAgICAgICAgc2VsZi5wYy5hZGRUcmFuc2NlaXZlcihcImF1ZGlvXCIsIHtkaXJlY3Rpb246IFwic2VuZG9ubHlcIn0pO1xuICAgICAgICBzZWxmLnBjLmFkZFRyYW5zY2VpdmVyKFwidmlkZW9cIiwge2RpcmVjdGlvbjogXCJzZW5kb25seVwifSk7XG5cbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzICYmIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHA6JyAmJiB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWUgIT09ICdsb2NhbGhvc3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3JzRXJyb3IoJ0h0dHBzUmVxdWlyZWRFcnJvcicsIGBQbGVhc2UgdXNlIEhUVFBTIG9yIGxvY2FsaG9zdCB0byBwdWJsaXNoLCByZWFkIGh0dHBzOi8vZ2l0aHViLmNvbS9vc3Nycy9zcnMvaXNzdWVzLzI3NjIjaXNzdWVjb21tZW50LTk4MzE0NzU3NmApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShzZWxmLmNvbnN0cmFpbnRzKTtcblxuICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENQZWVyQ29ubmVjdGlvbi9hZGRTdHJlYW0jTWlncmF0aW5nX3RvX2FkZFRyYWNrXG4gICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgICAgc2VsZi5wYy5hZGRUcmFjayh0cmFjayk7XG5cbiAgICAgICAgICAgIC8vIE5vdGlmeSBhYm91dCBsb2NhbCB0cmFjayB3aGVuIHN0cmVhbSBpcyBvay5cbiAgICAgICAgICAgIHNlbGYub250cmFjayAmJiBzZWxmLm9udHJhY2soe3RyYWNrOiB0cmFja30pO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgb2ZmZXIgPSBhd2FpdCBzZWxmLnBjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGF3YWl0IHNlbGYucGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIHZhciBzZXNzaW9uID0gYXdhaXQgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcnRjZG4vcnRjZG4tZHJhZnRcbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGFwaTogY29uZi5hcGlVcmwsIHRpZDogY29uZi50aWQsIHN0cmVhbXVybDogY29uZi5zdHJlYW1VcmwsXG4gICAgICAgICAgICAgICAgY2xpZW50aXA6IG51bGwsIHNkcDogb2ZmZXIuc2RwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJHZW5lcmF0ZWQgb2ZmZXI6IFwiLCBkYXRhKTtcblxuICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlICE9PSB4aHIuRE9ORSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzICE9PSAyMDApIHJldHVybiByZWplY3QoeGhyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkdvdCBhbnN3ZXI6IFwiLCBkYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5jb2RlID8gcmVqZWN0KHhocikgOiByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCBjb25mLmFwaVVybCwgdHJ1ZSk7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgICAgIHhoci5zZW5kKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHNlbGYucGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oXG4gICAgICAgICAgICBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHt0eXBlOiAnYW5zd2VyJywgc2RwOiBzZXNzaW9uLnNkcH0pXG4gICAgICAgICk7XG4gICAgICAgIHNlc3Npb24uc2ltdWxhdG9yID0gY29uZi5zY2hlbWEgKyAnLy8nICsgY29uZi51cmxPYmplY3Quc2VydmVyICsgJzonICsgY29uZi5wb3J0ICsgJy9ydGMvdjEvbmFjay8nO1xuXG4gICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgIH07XG5cbiAgICAvLyBDbG9zZSB0aGUgcHVibGlzaGVyLlxuICAgIHNlbGYuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucGMgJiYgc2VsZi5wYy5jbG9zZSgpO1xuICAgICAgICBzZWxmLnBjID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gVGhlIGNhbGxiYWNrIHdoZW4gZ290IGxvY2FsIHN0cmVhbS5cbiAgICAvLyBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENQZWVyQ29ubmVjdGlvbi9hZGRTdHJlYW0jTWlncmF0aW5nX3RvX2FkZFRyYWNrXG4gICAgc2VsZi5vbnRyYWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEFkZCB0cmFjayB0byBzdHJlYW0gb2YgU0RLLlxuICAgICAgICBzZWxmLnN0cmVhbS5hZGRUcmFjayhldmVudC50cmFjayk7XG4gICAgfTtcblxuICAgIC8vIEludGVybmFsIEFQSXMuXG4gICAgc2VsZi5fX2ludGVybmFsID0ge1xuICAgICAgICBkZWZhdWx0UGF0aDogJy9ydGMvdjEvcHVibGlzaC8nLFxuICAgICAgICBwcmVwYXJlVXJsOiBmdW5jdGlvbiAod2VicnRjVXJsKSB7XG4gICAgICAgICAgICB2YXIgdXJsT2JqZWN0ID0gc2VsZi5fX2ludGVybmFsLnBhcnNlKHdlYnJ0Y1VybCk7XG5cbiAgICAgICAgICAgIC8vIElmIHVzZXIgc3BlY2lmaWVzIHRoZSBzY2hlbWEsIHVzZSBpdCBhcyBBUEkgc2NoZW1hLlxuICAgICAgICAgICAgdmFyIHNjaGVtYSA9IHVybE9iamVjdC51c2VyX3F1ZXJ5LnNjaGVtYTtcbiAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYSA/IHNjaGVtYSArICc6JyA6IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcblxuICAgICAgICAgICAgdmFyIHBvcnQgPSB1cmxPYmplY3QucG9ydCB8fCAxOTg1O1xuICAgICAgICAgICAgaWYgKHNjaGVtYSA9PT0gJ2h0dHBzOicpIHtcbiAgICAgICAgICAgICAgICBwb3J0ID0gdXJsT2JqZWN0LnBvcnQgfHwgNDQzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ydGNkbi9ydGNkbi1kcmFmdFxuICAgICAgICAgICAgdmFyIGFwaSA9IHVybE9iamVjdC51c2VyX3F1ZXJ5LnBsYXkgfHwgc2VsZi5fX2ludGVybmFsLmRlZmF1bHRQYXRoO1xuICAgICAgICAgICAgaWYgKGFwaS5sYXN0SW5kZXhPZignLycpICE9PSBhcGkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGFwaSArPSAnLyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFwaVVybCA9IHNjaGVtYSArICcvLycgKyB1cmxPYmplY3Quc2VydmVyICsgJzonICsgcG9ydCArIGFwaTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB1cmxPYmplY3QudXNlcl9xdWVyeSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICdhcGknICYmIGtleSAhPT0gJ3BsYXknKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaVVybCArPSAnJicgKyBrZXkgKyAnPScgKyB1cmxPYmplY3QudXNlcl9xdWVyeVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgL3J0Yy92MS9wbGF5LyZrPXYgdG8gL3J0Yy92MS9wbGF5Lz9rPXZcbiAgICAgICAgICAgIHZhciBhcGlVcmwgPSBhcGlVcmwucmVwbGFjZShhcGkgKyAnJicsIGFwaSArICc/Jyk7XG5cbiAgICAgICAgICAgIHZhciBzdHJlYW1VcmwgPSB1cmxPYmplY3QudXJsO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFwaVVybDogYXBpVXJsLCBzdHJlYW1Vcmw6IHN0cmVhbVVybCwgc2NoZW1hOiBzY2hlbWEsIHVybE9iamVjdDogdXJsT2JqZWN0LCBwb3J0OiBwb3J0LFxuICAgICAgICAgICAgICAgIHRpZDogTnVtYmVyKHBhcnNlSW50KG5ldyBEYXRlKCkuZ2V0VGltZSgpKk1hdGgucmFuZG9tKCkqMTAwKSkudG9TdHJpbmcoMTYpLnNsaWNlKDAsIDcpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgLy8gQHNlZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDQ2OTU3NS9ob3ctdG8tdXNlLWxvY2F0aW9uLW9iamVjdC10by1wYXJzZS11cmwtd2l0aG91dC1yZWRpcmVjdGluZy10aGUtcGFnZS1pbi1qYXZhc2NyaVxuICAgICAgICAgICAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICAgICAgICAgIGEuaHJlZiA9IHVybC5yZXBsYWNlKFwicnRtcDovL1wiLCBcImh0dHA6Ly9cIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcIndlYnJ0YzovL1wiLCBcImh0dHA6Ly9cIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcInJ0YzovL1wiLCBcImh0dHA6Ly9cIik7XG5cbiAgICAgICAgICAgIHZhciB2aG9zdCA9IGEuaG9zdG5hbWU7XG4gICAgICAgICAgICB2YXIgYXBwID0gYS5wYXRobmFtZS5zdWJzdHJpbmcoMSwgYS5wYXRobmFtZS5sYXN0SW5kZXhPZihcIi9cIikpO1xuICAgICAgICAgICAgdmFyIHN0cmVhbSA9IGEucGF0aG5hbWUuc2xpY2UoYS5wYXRobmFtZS5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcblxuICAgICAgICAgICAgLy8gcGFyc2UgdGhlIHZob3N0IGluIHRoZSBwYXJhbXMgb2YgYXBwLCB0aGF0IHNycyBzdXBwb3J0cy5cbiAgICAgICAgICAgIGFwcCA9IGFwcC5yZXBsYWNlKFwiLi4udmhvc3QuLi5cIiwgXCI/dmhvc3Q9XCIpO1xuICAgICAgICAgICAgaWYgKGFwcC5pbmRleE9mKFwiP1wiKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtcyA9IGFwcC5zbGljZShhcHAuaW5kZXhPZihcIj9cIikpO1xuICAgICAgICAgICAgICAgIGFwcCA9IGFwcC5zbGljZSgwLCBhcHAuaW5kZXhPZihcIj9cIikpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5pbmRleE9mKFwidmhvc3Q9XCIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2aG9zdCA9IHBhcmFtcy5zbGljZShwYXJhbXMuaW5kZXhPZihcInZob3N0PVwiKSArIFwidmhvc3Q9XCIubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZob3N0LmluZGV4T2YoXCImXCIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmhvc3QgPSB2aG9zdC5zbGljZSgwLCB2aG9zdC5pbmRleE9mKFwiJlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHdoZW4gdmhvc3QgZXF1YWxzIHRvIHNlcnZlciwgYW5kIHNlcnZlciBpcyBpcCxcbiAgICAgICAgICAgIC8vIHRoZSB2aG9zdCBpcyBfX2RlZmF1bHRWaG9zdF9fXG4gICAgICAgICAgICBpZiAoYS5ob3N0bmFtZSA9PT0gdmhvc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmUgPSAvXihcXGQrKVxcLihcXGQrKVxcLihcXGQrKVxcLihcXGQrKSQvO1xuICAgICAgICAgICAgICAgIGlmIChyZS50ZXN0KGEuaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZob3N0ID0gXCJfX2RlZmF1bHRWaG9zdF9fXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBwYXJzZSB0aGUgc2NoZW1hXG4gICAgICAgICAgICB2YXIgc2NoZW1hID0gXCJydG1wXCI7XG4gICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoXCI6Ly9cIikgPiAwKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hID0gdXJsLnNsaWNlKDAsIHVybC5pbmRleE9mKFwiOi8vXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBvcnQgPSBhLnBvcnQ7XG4gICAgICAgICAgICBpZiAoIXBvcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5nZXIgb3V0IGJ5IHdlYnJ0YyB1cmwsIGlmIGNvbnRhaW5zIGh0dHAgb3IgaHR0cHMgcG9ydCwgdG8gb3ZlcndyaXRlIGRlZmF1bHQgMTk4NS5cbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hID09PSAnd2VicnRjJyAmJiB1cmwuaW5kZXhPZihgd2VicnRjOi8vJHthLmhvc3R9OmApID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcnQgPSAodXJsLmluZGV4T2YoYHdlYnJ0YzovLyR7YS5ob3N0fTo4MGApID09PSAwKSA/IDgwIDogNDQzO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEd1ZXNzIGJ5IHNjaGVtYS5cbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hID09PSAnaHR0cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9ydCA9IDgwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NoZW1hID09PSAnaHR0cHMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcnQgPSA0NDM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzY2hlbWEgPT09ICdydG1wJykge1xuICAgICAgICAgICAgICAgICAgICBwb3J0ID0gMTkzNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZXQgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiBzY2hlbWEsXG4gICAgICAgICAgICAgICAgc2VydmVyOiBhLmhvc3RuYW1lLCBwb3J0OiBwb3J0LFxuICAgICAgICAgICAgICAgIHZob3N0OiB2aG9zdCwgYXBwOiBhcHAsIHN0cmVhbTogc3RyZWFtXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2VsZi5fX2ludGVybmFsLmZpbGxfcXVlcnkoYS5zZWFyY2gsIHJldCk7XG5cbiAgICAgICAgICAgIC8vIEZvciB3ZWJydGMgQVBJLCB3ZSB1c2UgNDQzIGlmIHBhZ2UgaXMgaHR0cHMsIG9yIHNjaGVtYSBzcGVjaWZpZWQgaXQuXG4gICAgICAgICAgICBpZiAoIXJldC5wb3J0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYSA9PT0gJ3dlYnJ0YycgfHwgc2NoZW1hID09PSAncnRjJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0LnVzZXJfcXVlcnkuc2NoZW1hID09PSAnaHR0cHMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucG9ydCA9IDQ0MztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCdodHRwczovLycpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQucG9ydCA9IDQ0MztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBXZWJSVEMsIFNSUyB1c2UgMTk4NSBhcyBkZWZhdWx0IEFQSSBwb3J0LlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnBvcnQgPSAxOTg1O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9LFxuICAgICAgICBmaWxsX3F1ZXJ5OiBmdW5jdGlvbiAocXVlcnlfc3RyaW5nLCBvYmopIHtcbiAgICAgICAgICAgIC8vIHB1cmUgdXNlciBxdWVyeSBvYmplY3QuXG4gICAgICAgICAgICBvYmoudXNlcl9xdWVyeSA9IHt9O1xuXG4gICAgICAgICAgICBpZiAocXVlcnlfc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc3BsaXQgYWdhaW4gZm9yIGFuZ3VsYXJqcy5cbiAgICAgICAgICAgIGlmIChxdWVyeV9zdHJpbmcuaW5kZXhPZihcIj9cIikgPj0gMCkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5X3N0cmluZyA9IHF1ZXJ5X3N0cmluZy5zcGxpdChcIj9cIilbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBxdWVyaWVzID0gcXVlcnlfc3RyaW5nLnNwbGl0KFwiJlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVlcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtID0gcXVlcmllc1tpXTtcblxuICAgICAgICAgICAgICAgIHZhciBxdWVyeSA9IGVsZW0uc3BsaXQoXCI9XCIpO1xuICAgICAgICAgICAgICAgIG9ialtxdWVyeVswXV0gPSBxdWVyeVsxXTtcbiAgICAgICAgICAgICAgICBvYmoudXNlcl9xdWVyeVtxdWVyeVswXV0gPSBxdWVyeVsxXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWxpYXMgZG9tYWluIGZvciB2aG9zdC5cbiAgICAgICAgICAgIGlmIChvYmouZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgb2JqLnZob3N0ID0gb2JqLmRvbWFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLnBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKG51bGwpO1xuXG4gICAgLy8gVG8ga2VlcCBhcGkgY29uc2lzdGVudCBiZXR3ZWVuIHBsYXllciBhbmQgcHVibGlzaGVyLlxuICAgIC8vIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1BlZXJDb25uZWN0aW9uL2FkZFN0cmVhbSNNaWdyYXRpbmdfdG9fYWRkVHJhY2tcbiAgICAvLyBAc2VlIGh0dHBzOi8vd2VicnRjLm9yZy9nZXR0aW5nLXN0YXJ0ZWQvbWVkaWEtZGV2aWNlc1xuICAgIHNlbGYuc3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG5cbiAgICByZXR1cm4gc2VsZjtcbn1cblxuLy8gRGVwZW5kcyBvbiBhZGFwdGVyLTcuNC4wLm1pbi5qcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGMvYWRhcHRlclxuLy8gQXN5bmMtYXdhaXQtcHJvbWlzZSBiYXNlZCBTUlMgUlRDIFBsYXllci5cbmZ1bmN0aW9uIFNyc1J0Y1BsYXllckFzeW5jKCkge1xuICAgIHZhciBzZWxmID0ge307XG5cbiAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ydGNkbi9ydGNkbi1kcmFmdFxuICAgIC8vIEB1cmwgVGhlIFdlYlJUQyB1cmwgdG8gcGxheSB3aXRoLCBmb3IgZXhhbXBsZTpcbiAgICAvLyAgICAgIHdlYnJ0YzovL3Iub3NzcnMubmV0L2xpdmUvbGl2ZXN0cmVhbVxuICAgIC8vIG9yIHNwZWNpZmllcyB0aGUgQVBJIHBvcnQ6XG4gICAgLy8gICAgICB3ZWJydGM6Ly9yLm9zc3JzLm5ldDoxMTk4NS9saXZlL2xpdmVzdHJlYW1cbiAgICAvLyAgICAgIHdlYnJ0YzovL3Iub3NzcnMubmV0OjgwL2xpdmUvbGl2ZXN0cmVhbVxuICAgIC8vIG9yIGF1dG9zdGFydCB0aGUgcGxheTpcbiAgICAvLyAgICAgIHdlYnJ0YzovL3Iub3NzcnMubmV0L2xpdmUvbGl2ZXN0cmVhbT9hdXRvc3RhcnQ9dHJ1ZVxuICAgIC8vIG9yIGNoYW5nZSB0aGUgYXBwIGZyb20gbGl2ZSB0byBteWFwcDpcbiAgICAvLyAgICAgIHdlYnJ0YzovL3Iub3NzcnMubmV0OjExOTg1L215YXBwL2xpdmVzdHJlYW1cbiAgICAvLyBvciBjaGFuZ2UgdGhlIHN0cmVhbSBmcm9tIGxpdmVzdHJlYW0gdG8gbXlzdHJlYW06XG4gICAgLy8gICAgICB3ZWJydGM6Ly9yLm9zc3JzLm5ldDoxMTk4NS9saXZlL215c3RyZWFtXG4gICAgLy8gb3Igc2V0IHRoZSBhcGkgc2VydmVyIHRvIG15YXBpLmRvbWFpbi5jb206XG4gICAgLy8gICAgICB3ZWJydGM6Ly9teWFwaS5kb21haW4uY29tL2xpdmUvbGl2ZXN0cmVhbVxuICAgIC8vIG9yIHNldCB0aGUgY2FuZGlkYXRlKGVpcCkgb2YgYW5zd2VyOlxuICAgIC8vICAgICAgd2VicnRjOi8vci5vc3Nycy5uZXQvbGl2ZS9saXZlc3RyZWFtP2NhbmRpZGF0ZT0zOS4xMDcuMjM4LjE4NVxuICAgIC8vIG9yIGZvcmNlIHRvIGFjY2VzcyBodHRwcyBBUEk6XG4gICAgLy8gICAgICB3ZWJydGM6Ly9yLm9zc3JzLm5ldC9saXZlL2xpdmVzdHJlYW0/c2NoZW1hPWh0dHBzXG4gICAgLy8gb3IgdXNlIHBsYWludGV4dCwgd2l0aG91dCBTUlRQOlxuICAgIC8vICAgICAgd2VicnRjOi8vci5vc3Nycy5uZXQvbGl2ZS9saXZlc3RyZWFtP2VuY3J5cHQ9ZmFsc2VcbiAgICAvLyBvciBhbnkgb3RoZXIgaW5mb3JtYXRpb24sIHdpbGwgcGFzcy1ieSBpbiB0aGUgcXVlcnk6XG4gICAgLy8gICAgICB3ZWJydGM6Ly9yLm9zc3JzLm5ldC9saXZlL2xpdmVzdHJlYW0/dmhvc3Q9eHh4XG4gICAgLy8gICAgICB3ZWJydGM6Ly9yLm9zc3JzLm5ldC9saXZlL2xpdmVzdHJlYW0/dG9rZW49eHh4XG4gICAgc2VsZi5wbGF5ID0gYXN5bmMgZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIHZhciBjb25mID0gc2VsZi5fX2ludGVybmFsLnByZXBhcmVVcmwodXJsKTtcbiAgICAgICAgc2VsZi5wYy5hZGRUcmFuc2NlaXZlcihcImF1ZGlvXCIsIHtkaXJlY3Rpb246IFwicmVjdm9ubHlcIn0pO1xuICAgICAgICBzZWxmLnBjLmFkZFRyYW5zY2VpdmVyKFwidmlkZW9cIiwge2RpcmVjdGlvbjogXCJyZWN2b25seVwifSk7XG5cbiAgICAgICAgdmFyIG9mZmVyID0gYXdhaXQgc2VsZi5wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBhd2FpdCBzZWxmLnBjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IGF3YWl0IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcnRjZG4vcnRjZG4tZHJhZnRcbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgIGFwaTogY29uZi5hcGlVcmwsIHRpZDogY29uZi50aWQsIHN0cmVhbXVybDogY29uZi5zdHJlYW1VcmwsXG4gICAgICAgICAgICAgICAgY2xpZW50aXA6IG51bGwsIHNkcDogb2ZmZXIuc2RwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJHZW5lcmF0ZWQgb2ZmZXI6IFwiLCBkYXRhKTtcblxuICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlICE9PSB4aHIuRE9ORSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzICE9PSAyMDApIHJldHVybiByZWplY3QoeGhyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkdvdCBhbnN3ZXI6IFwiLCBkYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5jb2RlID8gcmVqZWN0KHhocikgOiByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeGhyLm9wZW4oJ1BPU1QnLCBjb25mLmFwaVVybCwgdHJ1ZSk7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgICAgIHhoci5zZW5kKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHNlbGYucGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oXG4gICAgICAgICAgICBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHt0eXBlOiAnYW5zd2VyJywgc2RwOiBzZXNzaW9uLnNkcH0pXG4gICAgICAgICk7XG4gICAgICAgIHNlc3Npb24uc2ltdWxhdG9yID0gY29uZi5zY2hlbWEgKyAnLy8nICsgY29uZi51cmxPYmplY3Quc2VydmVyICsgJzonICsgY29uZi5wb3J0ICsgJy9ydGMvdjEvbmFjay8nO1xuXG4gICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgIH07XG5cbiAgICAvLyBDbG9zZSB0aGUgcGxheWVyLlxuICAgIHNlbGYuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5wYyAmJiBzZWxmLnBjLmNsb3NlKCk7XG4gICAgICAgIHNlbGYucGMgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBUaGUgY2FsbGJhY2sgd2hlbiBnb3QgcmVtb3RlIHRyYWNrLlxuICAgIC8vIE5vdGUgdGhhdCB0aGUgb25hZGRzdHJlYW0gaXMgZGVwcmVjYXRlZCwgQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUlRDUGVlckNvbm5lY3Rpb24vb25hZGRzdHJlYW1cbiAgICBzZWxmLm9udHJhY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly93ZWJydGMub3JnL2dldHRpbmctc3RhcnRlZC9yZW1vdGUtc3RyZWFtc1xuICAgICAgICBzZWxmLnN0cmVhbS5hZGRUcmFjayhldmVudC50cmFjayk7XG4gICAgfTtcblxuICAgIC8vIEludGVybmFsIEFQSXMuXG4gICAgc2VsZi5fX2ludGVybmFsID0ge1xuICAgICAgICBkZWZhdWx0UGF0aDogJy9ydGMvdjEvcGxheS8nLFxuICAgICAgICBwcmVwYXJlVXJsOiBmdW5jdGlvbiAod2VicnRjVXJsKSB7XG4gICAgICAgICAgICB2YXIgdXJsT2JqZWN0ID0gc2VsZi5fX2ludGVybmFsLnBhcnNlKHdlYnJ0Y1VybCk7XG5cbiAgICAgICAgICAgIC8vIElmIHVzZXIgc3BlY2lmaWVzIHRoZSBzY2hlbWEsIHVzZSBpdCBhcyBBUEkgc2NoZW1hLlxuICAgICAgICAgICAgdmFyIHNjaGVtYSA9IHVybE9iamVjdC51c2VyX3F1ZXJ5LnNjaGVtYTtcbiAgICAgICAgICAgIHNjaGVtYSA9IHNjaGVtYSA/IHNjaGVtYSArICc6JyA6IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcblxuICAgICAgICAgICAgaWYoc2NoZW1hID09IFwiZmlsZTpcIil7XG4gICAgICAgICAgICAgICAgc2NoZW1hID0gXCJodHRwOlwiO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHNjaGVtYSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwb3J0ID0gdXJsT2JqZWN0LnBvcnQgfHwgMTk4NTtcbiAgICAgICAgICAgIGlmIChzY2hlbWEgPT09ICdodHRwczonKSB7XG4gICAgICAgICAgICAgICAgcG9ydCA9IHVybE9iamVjdC5wb3J0IHx8IDQ0MztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcnRjZG4vcnRjZG4tZHJhZnRcbiAgICAgICAgICAgIHZhciBhcGkgPSB1cmxPYmplY3QudXNlcl9xdWVyeS5wbGF5IHx8IHNlbGYuX19pbnRlcm5hbC5kZWZhdWx0UGF0aDtcbiAgICAgICAgICAgIGlmIChhcGkubGFzdEluZGV4T2YoJy8nKSAhPT0gYXBpLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBhcGkgKz0gJy8nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcGlVcmwgPSBzY2hlbWEgKyAnLy8nICsgdXJsT2JqZWN0LnNlcnZlciArICc6JyArIHBvcnQgKyBhcGk7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdXJsT2JqZWN0LnVzZXJfcXVlcnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnYXBpJyAmJiBrZXkgIT09ICdwbGF5Jykge1xuICAgICAgICAgICAgICAgICAgICBhcGlVcmwgKz0gJyYnICsga2V5ICsgJz0nICsgdXJsT2JqZWN0LnVzZXJfcXVlcnlba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXBsYWNlIC9ydGMvdjEvcGxheS8maz12IHRvIC9ydGMvdjEvcGxheS8/az12XG4gICAgICAgICAgICB2YXIgYXBpVXJsID0gYXBpVXJsLnJlcGxhY2UoYXBpICsgJyYnLCBhcGkgKyAnPycpO1xuXG4gICAgICAgICAgICB2YXIgc3RyZWFtVXJsID0gdXJsT2JqZWN0LnVybDtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhcGlVcmw6IGFwaVVybCwgc3RyZWFtVXJsOiBzdHJlYW1VcmwsIHNjaGVtYTogc2NoZW1hLCB1cmxPYmplY3Q6IHVybE9iamVjdCwgcG9ydDogcG9ydCxcbiAgICAgICAgICAgICAgICB0aWQ6IE51bWJlcihwYXJzZUludChuZXcgRGF0ZSgpLmdldFRpbWUoKSpNYXRoLnJhbmRvbSgpKjEwMCkpLnRvU3RyaW5nKDE2KS5zbGljZSgwLCA3KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIC8vIEBzZWU6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA0Njk1NzUvaG93LXRvLXVzZS1sb2NhdGlvbi1vYmplY3QtdG8tcGFyc2UtdXJsLXdpdGhvdXQtcmVkaXJlY3RpbmctdGhlLXBhZ2UtaW4tamF2YXNjcmlcbiAgICAgICAgICAgIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgICAgICBhLmhyZWYgPSB1cmwucmVwbGFjZShcInJ0bXA6Ly9cIiwgXCJodHRwOi8vXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJ3ZWJydGM6Ly9cIiwgXCJodHRwOi8vXCIpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoXCJydGM6Ly9cIiwgXCJodHRwOi8vXCIpO1xuXG4gICAgICAgICAgICB2YXIgdmhvc3QgPSBhLmhvc3RuYW1lO1xuICAgICAgICAgICAgdmFyIGFwcCA9IGEucGF0aG5hbWUuc3Vic3RyaW5nKDEsIGEucGF0aG5hbWUubGFzdEluZGV4T2YoXCIvXCIpKTtcbiAgICAgICAgICAgIHZhciBzdHJlYW0gPSBhLnBhdGhuYW1lLnNsaWNlKGEucGF0aG5hbWUubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG5cbiAgICAgICAgICAgIC8vIHBhcnNlIHRoZSB2aG9zdCBpbiB0aGUgcGFyYW1zIG9mIGFwcCwgdGhhdCBzcnMgc3VwcG9ydHMuXG4gICAgICAgICAgICBhcHAgPSBhcHAucmVwbGFjZShcIi4uLnZob3N0Li4uXCIsIFwiP3Zob3N0PVwiKTtcbiAgICAgICAgICAgIGlmIChhcHAuaW5kZXhPZihcIj9cIikgPj0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBhcHAuc2xpY2UoYXBwLmluZGV4T2YoXCI/XCIpKTtcbiAgICAgICAgICAgICAgICBhcHAgPSBhcHAuc2xpY2UoMCwgYXBwLmluZGV4T2YoXCI/XCIpKTtcblxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuaW5kZXhPZihcInZob3N0PVwiKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmhvc3QgPSBwYXJhbXMuc2xpY2UocGFyYW1zLmluZGV4T2YoXCJ2aG9zdD1cIikgKyBcInZob3N0PVwiLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aG9zdC5pbmRleE9mKFwiJlwiKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZob3N0ID0gdmhvc3Quc2xpY2UoMCwgdmhvc3QuaW5kZXhPZihcIiZcIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3aGVuIHZob3N0IGVxdWFscyB0byBzZXJ2ZXIsIGFuZCBzZXJ2ZXIgaXMgaXAsXG4gICAgICAgICAgICAvLyB0aGUgdmhvc3QgaXMgX19kZWZhdWx0Vmhvc3RfX1xuICAgICAgICAgICAgaWYgKGEuaG9zdG5hbWUgPT09IHZob3N0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlID0gL14oXFxkKylcXC4oXFxkKylcXC4oXFxkKylcXC4oXFxkKykkLztcbiAgICAgICAgICAgICAgICBpZiAocmUudGVzdChhLmhvc3RuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB2aG9zdCA9IFwiX19kZWZhdWx0Vmhvc3RfX1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcGFyc2UgdGhlIHNjaGVtYVxuICAgICAgICAgICAgdmFyIHNjaGVtYSA9IFwicnRtcFwiO1xuICAgICAgICAgICAgaWYgKHVybC5pbmRleE9mKFwiOi8vXCIpID4gMCkge1xuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHVybC5zbGljZSgwLCB1cmwuaW5kZXhPZihcIjovL1wiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBwb3J0ID0gYS5wb3J0O1xuICAgICAgICAgICAgaWYgKCFwb3J0KSB7XG4gICAgICAgICAgICAgICAgLy8gRmluZ2VyIG91dCBieSB3ZWJydGMgdXJsLCBpZiBjb250YWlucyBodHRwIG9yIGh0dHBzIHBvcnQsIHRvIG92ZXJ3cml0ZSBkZWZhdWx0IDE5ODUuXG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYSA9PT0gJ3dlYnJ0YycgJiYgdXJsLmluZGV4T2YoYHdlYnJ0YzovLyR7YS5ob3N0fTpgKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBwb3J0ID0gKHVybC5pbmRleE9mKGB3ZWJydGM6Ly8ke2EuaG9zdH06ODBgKSA9PT0gMCkgPyA4MCA6IDQ0MztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHdWVzcyBieSBzY2hlbWEuXG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYSA9PT0gJ2h0dHAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvcnQgPSA4MDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNjaGVtYSA9PT0gJ2h0dHBzJykge1xuICAgICAgICAgICAgICAgICAgICBwb3J0ID0gNDQzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NoZW1hID09PSAncnRtcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9ydCA9IDE5MzU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLFxuICAgICAgICAgICAgICAgIHNlcnZlcjogYS5ob3N0bmFtZSwgcG9ydDogcG9ydCxcbiAgICAgICAgICAgICAgICB2aG9zdDogdmhvc3QsIGFwcDogYXBwLCBzdHJlYW06IHN0cmVhbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbGYuX19pbnRlcm5hbC5maWxsX3F1ZXJ5KGEuc2VhcmNoLCByZXQpO1xuXG4gICAgICAgICAgICAvLyBGb3Igd2VicnRjIEFQSSwgd2UgdXNlIDQ0MyBpZiBwYWdlIGlzIGh0dHBzLCBvciBzY2hlbWEgc3BlY2lmaWVkIGl0LlxuICAgICAgICAgICAgaWYgKCFyZXQucG9ydCkge1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWEgPT09ICd3ZWJydGMnIHx8IHNjaGVtYSA9PT0gJ3J0YycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldC51c2VyX3F1ZXJ5LnNjaGVtYSA9PT0gJ2h0dHBzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnBvcnQgPSA0NDM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod2luZG93LmxvY2F0aW9uLmhyZWYuaW5kZXhPZignaHR0cHM6Ly8nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0LnBvcnQgPSA0NDM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgV2ViUlRDLCBTUlMgdXNlIDE5ODUgYXMgZGVmYXVsdCBBUEkgcG9ydC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldC5wb3J0ID0gMTk4NTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsbF9xdWVyeTogZnVuY3Rpb24gKHF1ZXJ5X3N0cmluZywgb2JqKSB7XG4gICAgICAgICAgICAvLyBwdXJlIHVzZXIgcXVlcnkgb2JqZWN0LlxuICAgICAgICAgICAgb2JqLnVzZXJfcXVlcnkgPSB7fTtcblxuICAgICAgICAgICAgaWYgKHF1ZXJ5X3N0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNwbGl0IGFnYWluIGZvciBhbmd1bGFyanMuXG4gICAgICAgICAgICBpZiAocXVlcnlfc3RyaW5nLmluZGV4T2YoXCI/XCIpID49IDApIHtcbiAgICAgICAgICAgICAgICBxdWVyeV9zdHJpbmcgPSBxdWVyeV9zdHJpbmcuc3BsaXQoXCI/XCIpWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcXVlcmllcyA9IHF1ZXJ5X3N0cmluZy5zcGxpdChcIiZcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IHF1ZXJpZXNbaV07XG5cbiAgICAgICAgICAgICAgICB2YXIgcXVlcnkgPSBlbGVtLnNwbGl0KFwiPVwiKTtcbiAgICAgICAgICAgICAgICBvYmpbcXVlcnlbMF1dID0gcXVlcnlbMV07XG4gICAgICAgICAgICAgICAgb2JqLnVzZXJfcXVlcnlbcXVlcnlbMF1dID0gcXVlcnlbMV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFsaWFzIGRvbWFpbiBmb3Igdmhvc3QuXG4gICAgICAgICAgICBpZiAob2JqLmRvbWFpbikge1xuICAgICAgICAgICAgICAgIG9iai52aG9zdCA9IG9iai5kb21haW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gY29uc3QgcGNPcHRpb25hbCA9e1xuICAgIC8vICAgICBvcHRpb25hbDpbe2dvb2dDcHVPdmVydXNlRGV0ZWN0aW9uOmZhbHNlfV1cbiAgICAvLyAgIH07XG4gICAgLy8gY29uc3QgY29uZmlndXJhdGlvbiA9IHtcbiAgICAvLyAgICAgaWNlU2VydmVyczogW3tcbiAgICAvLyAgICAgICAgIHVybHM6IFwidHVybjphdmMuYWdyZWUuY246NTAxMTFcIixcbiAgICAvLyAgICAgICAgIHVzZXJuYW1lOiBcImFncmVlXCIsXG4gICAgLy8gICAgICAgICBjcmVkZW50aWFsOiBcImFncmVlXCJcbiAgICAvLyAgICAgfV0sIFxuICAgIC8vICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6IFwicmVsYXlcIlxuICAgIC8vIH1cbiAgICAvLyBzZWxmLnBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKGNvbmZpZ3VyYXRpb24scGNPcHRpb25hbCk7XG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgc2VsZi5wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihudWxsKTtcblxuICAgIC8vIENyZWF0ZSBhIHN0cmVhbSB0byBhZGQgdHJhY2sgdG8gdGhlIHN0cmVhbSwgQHNlZSBodHRwczovL3dlYnJ0Yy5vcmcvZ2V0dGluZy1zdGFydGVkL3JlbW90ZS1zdHJlYW1zXG4gICAgc2VsZi5zdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcblxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENQZWVyQ29ubmVjdGlvbi9vbnRyYWNrXG4gICAgc2VsZi5wYy5vbnRyYWNrID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKHNlbGYub250cmFjaykge1xuICAgICAgICAgICAgc2VsZi5vbnRyYWNrKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gc2VsZjtcbn1cblxuLy8gRm9ybWF0IHRoZSBjb2RlYyBvZiBSVENSdHBTZW5kZXIsIGtpbmQoYXVkaW8vdmlkZW8pIGlzIG9wdGlvbmFsIGZpbHRlci5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL01lZGlhL0Zvcm1hdHMvV2ViUlRDX2NvZGVjcyNnZXR0aW5nX3RoZV9zdXBwb3J0ZWRfY29kZWNzXG5mdW5jdGlvbiBTcnNSdGNGb3JtYXRTZW5kZXJzKHNlbmRlcnMsIGtpbmQpIHtcbiAgICB2YXIgY29kZWNzID0gW107XG4gICAgc2VuZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChzZW5kZXIpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtcyAmJiBwYXJhbXMuY29kZWNzICYmIHBhcmFtcy5jb2RlY3MuZm9yRWFjaChmdW5jdGlvbihjKSB7XG4gICAgICAgICAgICBpZiAoa2luZCAmJiBzZW5kZXIudHJhY2sua2luZCAhPT0ga2luZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGMubWltZVR5cGUuaW5kZXhPZignL3JlZCcpID4gMCB8fCBjLm1pbWVUeXBlLmluZGV4T2YoJy9ydHgnKSA+IDAgfHwgYy5taW1lVHlwZS5pbmRleE9mKCcvZmVjJykgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcyA9ICcnO1xuXG4gICAgICAgICAgICBzICs9IGMubWltZVR5cGUucmVwbGFjZSgnYXVkaW8vJywgJycpLnJlcGxhY2UoJ3ZpZGVvLycsICcnKTtcbiAgICAgICAgICAgIHMgKz0gJywgJyArIGMuY2xvY2tSYXRlICsgJ0haJztcbiAgICAgICAgICAgIGlmIChzZW5kZXIudHJhY2sua2luZCA9PT0gXCJhdWRpb1wiKSB7XG4gICAgICAgICAgICAgICAgcyArPSAnLCBjaGFubmVsczogJyArIGMuY2hhbm5lbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzICs9ICcsIHB0OiAnICsgYy5wYXlsb2FkVHlwZTtcblxuICAgICAgICAgICAgY29kZWNzLnB1c2gocyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBjb2RlY3Muam9pbihcIiwgXCIpO1xufVxuXG5leHBvcnQge1Nyc1J0Y1BsYXllckFzeW5jfSIsImltcG9ydCB7U3JzUnRjUGxheWVyQXN5bmN9IGZyb20gXCIuL3Nycy5zZGtcIjtcclxuXHJcbmNsYXNzIGNsaWVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnBsYXllcnMgPVtdO1xyXG4gICAgICAgIHRoaXMucGxheVZpZGVvcyA9W107XHJcbiAgICB9XHJcbiAgICBpbml0UGxheWVyKHN0cmVhbUFsaWFzKXtcclxuICAgICAgICB0aGlzLnBsYXllcnNbc3RyZWFtQWxpYXNdID0gbmV3IFNyc1J0Y1BsYXllckFzeW5jKCk7XHJcbiAgICB9XHJcbiAgICBwbGF5KHVybCx2aWRlbyxzdHJlYW1BbGlhcyl7XHJcbiAgICAgICAgdGhpcy5wbGF5VmlkZW9zW3N0cmVhbUFsaWFzXSA9IHZpZGVvO1xyXG4gICAgICAgIGxldCBwbGF5ZXIgPXRoaXMucGxheWVyc1tzdHJlYW1BbGlhc107XHJcbiAgICAgICAgdmlkZW8uc3JjT2JqZWN0ID0gcGxheWVyLnN0cmVhbTtcclxuICAgICAgICBwbGF5ZXIucGxheSh1cmwpLnRoZW4oZnVuY3Rpb24gKHNlc3Npb24pIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2codXJsKTtcclxuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAocmVhc29uKSB7XHJcbiAgICAgICAgICAgIHBsYXllci5jbG9zZSgpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKHJlYXNvbik7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdG9wUGxheShzdHJlYW1BbGlhcyl7XHJcbiAgICAgICAgdGhpcy5wbGF5VmlkZW9zW3N0cmVhbUFsaWFzXS5zcmNPYmplY3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGxheWVyc1tzdHJlYW1BbGlhc10uY2xvc2UoKTtcclxuICAgIH1cclxufVxyXG5jbGllbnQgPSBuZXcgY2xpZW50KCk7XHJcbmV4cG9ydCBkZWZhdWx0IGNsaWVudDtcclxuIiwiaW1wb3J0IGNsaWVudCBmcm9tIFwiLi9pbmRleFwiXHJcbndpbmRvdy5hbXBzU0RLID0ge1xyXG4gICAgaW5pdFBsYXllcjogZnVuY3Rpb24gKHN0cmVhbUFsaWFzKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJBTVBTLWluaXRQbGF5ZXJcIik7XHJcbiAgICAgICAgY2xpZW50LmluaXRQbGF5ZXIoc3RyZWFtQWxpYXMpO1xyXG4gICAgfSxcclxuICAgIHBsYXk6IGZ1bmN0aW9uICh1cmwsdmlkZW8sc3RyZWFtQWxpYXMpIHsgXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJBTVBTLXBsYXlcIik7XHJcbiAgICAgICAgY2xpZW50LnBsYXkodXJsLHZpZGVvLHN0cmVhbUFsaWFzKTtcclxuICAgIH0sXHJcbiAgICBzdG9wUGxheTogZnVuY3Rpb24gKHN0cmVhbUFsaWFzKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJBTVBTLXN0b3BQbGF5XCIpO1xyXG4gICAgICAgIGNsaWVudC5zdG9wUGxheShzdHJlYW1BbGlhcyk7XHJcbiAgICB9XHJcblxyXG59Il0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')}])}));